<html lang="en">
	<head>
		<title>MMD motion regeneration</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="shortcut icon" href='{{ url_for('static', filename='favicon.ico') }}'>
		<link rel='stylesheet' href='{{ url_for('static', filename='css/main.css') }}'>
	</head>

	<body>
		<div class="booth">
			<video width="320" height="240" id="player" controls autoplay></video>
		</div>
		<div id="btn" style="position:absolute;left:87%;top:110px;">
			<button type="button" id="start" style="border-radius:8px;width:100px;height:28px;z-index:999;background:white;border:1px solid silver;">START</button>
			<button type="button" id="stop" style="border-radius:8px;width:100px;height:28px;display:none;z-index:999;background:white;border:1px solid silver;">RELOAD</button>
			<button type="button" id="playonce" style="border-radius:8px;width:100px;height:28px;z-index:999;background:white;border:1px solid silver;">PLAY ONCE</button>
			<!-- <button type="button" id="capture" style="border-radius:8px;width:100px;height:25px;z-index:999;">CAPTURE</button> -->
			<p id="gaze" style="font-size:16px;">Gaze:</p>
			<p id="emotion" style="font-size:16px;">Emotion:</p>
			<canvas id='snapshot' width=320 height=240 style="display:none;"></canvas>
		</div>

		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/build/three.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/libs/mmdparser.min.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/libs/ammo.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/loaders/TGALoader.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/loaders/MMDLoader.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/effects/OutlineEffect.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/animation/CCDIKSolver.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/animation/MMDPhysics.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/controls/OrbitControls.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/Detector.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r87/examples/js/libs/dat.gui.min.js"></script>
		<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
		<script src='{{ url_for('static', filename='js/recorder.js') }}'></script>
		<script src='{{ url_for('static', filename='js/indicator.js') }}'></script>
		<script src='{{ url_for('static', filename='js/noise.js') }}'></script>
		<script id="updateMotion">

			$("#start").click(function(){initiate();});
			$("#stop").click(function(){stop();});
			$("#playonce").click(function(){playOnce('2');});

			function playOnce(motionFile){
				loadMotion(motionFile, function(){
					updateMotion(function(){
						console.log('motionFile');
						// motionParams.splice(0,1);
						// mesh.geometry.animations.splice(1,1);
					})
				})
			}

			// var player, snapshotCanvas;

			var currentMotion;

			var scene, camera;

			var renderer, effect;

			var mesh, renderTarget;

			var helper;

			var modelParams = [
				{
					name: 'miku',
					file: 'https://cdn.rawgit.com/mrdoob/three.js/r87/examples/models/mmd/miku/miku_v2.pmd',
					position: new THREE.Vector3( 0, -15,  0 )
				}
			];

			var poseParams = [
				{
					name: 'basic',
					file: 'static/vpd/makoto_basic.vpd'
				}
			];

			var motionParams = [];

			var poses = {};

			var audio = new Audio("{{ url_for('static', filename='audio/sample.wav') }}");

			var ready = false;

			var clock = new THREE.Clock();

			var onProgress = function ( xhr ) {
				if ( xhr.lengthComputable ) {
					var percentComplete = xhr.loaded / xhr.total * 100;
					console.log( Math.round(percentComplete, 2) + '% downloaded' );
				}
			};

			var onError = function ( xhr ) {
			};

			helper = new THREE.MMDHelper();
			mesh = helper.meshes[ 0 ];
			audio.loop = true;

			init();
			animate();

			function init() {
				var container;
				var blinkMorphName = 'まばたき';
				var blinkVmd = {
					metadata: {
						name: 'blink',
						coordinateSystem: 'right',
						morphCount: 11,
						cameraCount: 0,
						motionCount: 0
					},
					morphs: [
						{ frameNum:   0, morphName: blinkMorphName, weight: 0.0 },
						{ frameNum:  10, morphName: blinkMorphName, weight: 0.0 },
						{ frameNum:  15, morphName: blinkMorphName, weight: 1.0 },
						{ frameNum:  20, morphName: blinkMorphName, weight: 0.0 },
						{ frameNum:  40, morphName: blinkMorphName, weight: 0.0 },
						{ frameNum:  43, morphName: blinkMorphName, weight: 1.0 },
						{ frameNum:  46, morphName: blinkMorphName, weight: 0.0 },
						{ frameNum:  49, morphName: blinkMorphName, weight: 0.0 },
						{ frameNum:  52, morphName: blinkMorphName, weight: 1.0 },
						{ frameNum:  55, morphName: blinkMorphName, weight: 0.0 },
						{ frameNum: 200, morphName: blinkMorphName, weight: 0.0 },
					],
					cameras: [],
					motions: []
				};

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// cameras

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.y = 0
				camera.up.y = 1
				camera.position.z = 15;

				var controls = new THREE.OrbitControls( camera );
				controls.minPolarAngle = 1.3; // radians
				controls.maxPolarAngle = 1.7; // radians

				controls.minAzimuthAngle = - 0.3; // radians
				controls.maxAzimuthAngle = 0.3; // radians

				// scene

				scene = new THREE.Scene();

				// lights

				var ambient = new THREE.AmbientLight( 0x444444 );
				scene.add( ambient );

				var directionalLight = new THREE.DirectionalLight( 0x666666 );
				directionalLight.position.set( -1, 1, 1 ).normalize();
				scene.add( directionalLight );

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( new THREE.Color( 0XFFFFFF ) );
				container.appendChild( renderer.domElement );
				effect = new THREE.OutlineEffect( renderer );

				renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );

				// model

				loader = new THREE.MMDLoader();

				loadModels( function () {

					loadVpds( mesh, function () {

						helper.poseAsVpd( mesh, poses[ 'basic' ] );
						loadVmds( mesh, function () {

							loader.pourVmdIntoModel( mesh, blinkVmd, 'blink' );
							helper.setAnimation( mesh );
							ready = true;

						} );
					} );
				} );
				window.addEventListener( 'resize', onWindowResize, false );
			}

			const start = function(){
					setTimeout(function(){
						mmdLoop().then(function(){
								start();
						});
					},0)
			}

			function audioPlay(res){
				audio.volumn = 1/res['proportion'];
				console.log(audio.volumn);
			}
			// startRecord();
			// send a request and start sampling from roadmap
			function initiate() {
				// return new Promise(function(resolve){
				currentBtnR = document.getElementById("start");
				currentBtnS = document.getElementById("stop");
				currentBtnR.style.display = "none";
				currentBtnS.style.display = "inline";
				$.ajax({
					async: true,
					url: '/initate',
					cache: false,
					success: function(res){
						var res = JSON.parse(res);
						loadMotion(res['timenow'], function(){
							updateMotion(function(){
								setTimeout(function(){
									audio.play();
									audioPlay(res);
									start();
								},0)
								// audioPlay(res);
								// startRecord();
							});
						});
					}
				})
				// })
			}

			// keep download motion files
			function mmdLoop(){
				return new Promise(function(resolve){
	        console.log('sending request...')
					$.ajax({
						async: true,
						url: '/gene_motion',
						cache: false,
						success: function(res){
							var res = JSON.parse(res);
							loadMotion(res['timenow'], function(){
								var time = mesh.geometry.animations[1].duration - mesh.mixer.clipAction( motionParams[0].name ).time - clock.getDelta();
								console.log('sleep time: %f', time);
								setTimeout(function(){
								  motionParams.splice(0,1);
								  mesh.geometry.animations.splice(1,1);
									updateMotion(function(){
										// audioPlay(res);
										setTimeout(function(){
											audioPlay(res);
										},0)
										resolve()
									});
								}, (time-1)*1000);
							})
						}
					})
				})
			}

			// stop download motion file and update motion
			function stop(){
				currentBtnR = document.getElementById("start");
				currentBtnS = document.getElementById("stop");
				currentBtnR.style.display = "inline";
				currentBtnS.style.display = "none";

				location.reload();
			}

			function loadMotion(res, callback){
        console.log('loading...');
				var tmp = {
					name: res,
					files: [ 'static/vmd/'+ res +'.vmd' ]
				};

				motionParams.push(tmp);

				var param = motionParams[ motionParams.length - 1 ];

				loader.loadVmds( param.files, function ( vmd ) {

					loader.pourVmdIntoModel( mesh, vmd, param.name );

					callback();

				}, onProgress, onError );

			}

			function	updateMotion(callback){

        console.log('updating...');
				// if(currentMotion != undefined){
				// 	mesh.mixer.clipAction( currentMotion).weight = 0.5;
				// }
				console.log(mesh.geometry.animations);

				currentMotion = motionParams[0].name;
        console.log('motion name: %s', currentMotion);
				var action = mesh.mixer.clipAction( currentMotion )
				stopAll();
				action.play();
				action.loop = THREE.LoopOnce;
				action.clampWhenFinished = true;
				startBlink();

				// update();

				callback();

			}

			function stopAll(){
				mesh.mixer.stopAllAction();
			}

			function startBlink(){
				mesh.mixer.clipAction( 'blinkMorph' ).play();
			}

			function loadModels ( callback ) {

				function load ( index ) {

					if ( index >= modelParams.length ) {

						callback();
						return;

					}

					var param = modelParams[ index ];

					loader.loadModel( param.file, function ( object ) {

						mesh = object;
						mesh.position.y = -16.1;

						helper.add( mesh );
						helper.setPhysics( mesh );

						scene.add( mesh );
						ringing = new THREE.PolarGridHelper( 50, 10 );
						ringing.position.y = -16;
						scene.add( ringing );

						load( index + 1 );

					}, onProgress, onError );

				}

				load( 0 );

			}

			function loadVmds ( mesh, callback ) {

				function load ( index ) {

					if ( index >= motionParams.length ) {

						callback();
						return;

					}

					var param = motionParams[ index ];

					loader.loadVmds( param.files, function ( vmd ) {

						loader.createAnimation( mesh, vmd, param.name );

						load( index + 1 );

					}, onProgress, onError );

				}

				load( 0 );

			}

			function loadVpds ( mesh, callback ) {

				function load ( index ) {

					if ( index >= poseParams.length ) {

						callback();
						return;

					}

					var param = poseParams[ index ];

					loader.loadVpd( param.file, function ( vpd ) {

						poses[ param.name ] = vpd;

						load( index + 1 );

					}, onProgress, onError );

				}

				load( 0 );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				effect.setSize( window.innerWidth, window.innerHeight );
				renderTarget.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );
				update();
				render();

			}

			function update() {

				if ( ! ready ) return;

				var delta = clock.getDelta();

				helper.animate( delta );

			}

			function render() {

				if ( ready ) {

					// pass : render model

					mesh.visible = true;

					effect.render( scene, camera );


					// just in case restore the parameters

					renderer.autoClear = true;

					mesh.visible = true;

				} else {

					renderer.render( scene, camera );

				}

			}

		</script>
	</body>
</html>
